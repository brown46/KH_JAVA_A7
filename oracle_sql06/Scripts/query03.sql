/*
 * 특정 직무에 대한 급여 테이블을 일정 퍼센트 상승 및 감소를 시킨 경우
 * JOBS 테이블의 MIN_SALARY, MAX_SALARY 컬럼의 값과
 * EMPLOYEES 테이블에 동일 직무를 부여 받은 사원의 SALARY 컬럼의 값을
 * 변경하는 PROCEDURE 를 생성한다.
 * 
 * 프로시져의 실행 결과로 몇개의 행이 반영되었는지 반환할 수 있게 한다. 
 */
CREATE OR REPLACE PROCEDURE PROC_INC_JOB_SALARY(
       JOBID IN VARCHAR2
     , PERCENT IN NUMBER
     , UPDATE_ROWS OUT NUMBER
)
IS
    R_COUNT NUMBER;
    UPPER_JOB_ID VARCHAR2(20);
BEGIN
	UPPER_JOB_ID := UPPER(JOBID);
    UPDATE_ROWS := 0;

    IF(PERCENT > -100 AND PERCENT < 100) THEN
        SELECT COUNT(*)
          INTO R_COUNT
          FROM JOBS
         WHERE JOB_ID = UPPER_JOB_ID;
        
        UPDATE_ROWS := UPDATE_ROWS + R_COUNT;
        
        UPDATE JOBS
           SET MIN_SALARY = MIN_SALARY * (1 + PERCENT/100)
             , MAX_SALARY = MAX_SALARY * (1 + PERCENT/100)
         WHERE JOB_ID = UPPER_JOB_ID;
        
        SELECT COUNT(*)
          INTO R_COUNT
          FROM EMPLOYEES
         WHERE JOB_ID = UPPER_JOB_ID;
        
        UPDATE_ROWS := UPDATE_ROWS + R_COUNT;
    
        UPDATE EMPLOYEES
           SET SALARY = SALARY * (1 + PERCENT/100)
         WHERE JOB_ID = UPPER_JOB_ID;
    END IF;
END;

SELECT * FROM USER_ERRORS;

DECLARE
    ROW_COUNT NUMBER;
BEGIN
    PROC_INC_JOB_SALARY('IT_PROG', -2, ROW_COUNT);  /* 양수는 증가 */
    PROC_INC_JOB_SALARY('IT_PROG', -1, ROW_COUNT); /* 음수는 감소 */
    PROC_INC_JOB_SALARY('it_prog', 4, ROW_COUNT);  /* 소문자도 처리 가능 */
    PROC_INC_JOB_SALARY('it', 0.4, ROW_COUNT);       /* 잘못된 JOB_ID 는 오류 없이 0개행 반영으로 종료 */
    PROC_INC_JOB_SALARY('IT_PROG', 100, ROW_COUNT);   /* -100 초과 ~ 100 미만 의 범위만 처리, 그 외 범위는 0개행 반영으로 종료 */
    DBMS_OUTPUT.PUT_LINE(ROW_COUNT || ' 개 행이 반영되었습니다.');
END;

DECLARE
    ROW_COUNT NUMBER;
BEGIN
    PROC_INC_JOB_SALARY('IT_PROG', -2, ROW_COUNT);  /* 양수는 증가 */
	DBMS_OUTPUT.PUT_LINE(ROW_COUNT || ' 개 행이 반영되었습니다.');
END;



/*
 * LOGIN테이블을 생성한다
 * 		USERNAME: 사용자 ID가 저장될 컬럼
 * 		PASSWORD: 패스워드가 저장될 컬럼
 *		TRY_CNT: 시도 횟수가 저장될 컬럼
 *		LOGIN_LOCK: 로그인 잠김 유무가 저장될 컬럼
 *		LOCK_DATE: 로그인 잠김이 활성화된 날짜가 저장될 컬럼
 *
 * USERNAME과 PASSWORD를 입력 받을 수 있는 PROCEDURE를 작성하여
 * 올바른 정보를 입력한 경우 '로그인 성공' 을 출력하고 별도의 LOGIN_LOG 테이블에
 * USERNAME, 로그인 성공 날짜 정보가 기록될 수 있게 한다.
 * 
 * 만약 올바른 정보를 입력하지 않은 경우 '로그인 실패' 를 출력하고 로그인 시도 횟수가 저장되는 컬럼에
 * 값을 1 증가시킨다.(로그인 실패를 했을 때에도 LOGIN_LOG테이블에 USERNAME, 로그인 실패 날짜 정보가 기록되게 한다.)
 * 
 * 로그인 시도 횟수는 최대 3번이며, 3번째에서 실패를 한 경우 계정은 잠금상태가 되어 5분간 로그인 시도를 할 수 없다. 
 * (5분이 지난 후에는 다시 로그인을 시도할 수 있다.)
 * 
 * 로그인 시도 횟수는 로그인이 성공했을 때 다시 0으로 초기화 된다.
 */
CREATE TABLE LOGIN(
	   USERNAME VARCHAR2(20) PRIMARY KEY
	 , PASSWORD VARCHAR2(20)
	 , TRY_CNT NUMBER DEFAULT 0
	 , LOGIN_LOCK NUMBER DEFAULT 0
	 , LOCK_DATE DATE
);

DROP TABLE LOGIN;
INSERT INTO LOGIN VALUES('ID1','PW1',0,0,TO_DATE(19000101));
INSERT INTO LOGIN VALUES('ID2','PW2',0,0,TO_DATE(19000101));
INSERT INTO LOGIN VALUES('ID3','PW3',0,0,TO_DATE(19000101));
INSERT INTO LOGIN VALUES('ID4','PW4',0,0,TO_DATE(19000101));

CREATE TABLE LOGIN_LOG(
	   ROW_NUM NUMBER
	 , USERNAME VARCHAR2(20)
	 , LOGIN_DATE DATE
	 , LOG_STATE VARCHAR2(20)
);
DROP TABLE LOGIN_LOG;
CREATE SEQUENCE SEQ_LOG NOCACHE;

SELECT * FROM LOGIN;
SELECT * FROM LOGIN_LOG;

CREATE OR REPLACE PROCEDURE PROC_LOGIN(ID IN VARCHAR2,PW IN VARCHAR2)
IS 
	RID VARCHAR2(20);
	RPW VARCHAR2(20);
	RCT VARCHAR2(20);
	RLD DATE;
BEGIN 
	SELECT USERNAME,PASSWORD,TRY_CNT,LOCK_DATE
	  INTO RID,RPW,RCT,RLD
	  FROM LOGIN
	 WHERE USERNAME=ID;
	
	IF SYSDATE > RLD THEN
		IF RPW!=PW THEN 
			DBMS_OUTPUT.PUT_LINE('비밀번호가 일치하지 않습니다. '||TO_CHAR(2-RCT)||'회 남음');
			UPDATE LOGIN SET TRY_CNT= TRY_CNT+1 WHERE USERNAME=ID;
			INSERT INTO LOGIN_LOG VALUES( SEQ_LOG.NEXTVAL,RID, SYSDATE,'FAIL' );
		ELSIF RPW=PW THEN 
			DBMS_OUTPUT.PUT_LINE('로그인 성공');
			INSERT INTO LOGIN_LOG VALUES( SEQ_LOG.NEXTVAL,RID, SYSDATE,'SUCCESS' );
			UPDATE LOGIN SET TRY_CNT= 0, LOGIN_LOCK= 0 WHERE USERNAME=RID;
			SELECT TRY_CNT INTO RCT FROM LOGIN WHERE USERNAME=ID;
		END IF;
		IF RCT>1 THEN
			UPDATE LOGIN SET LOGIN_LOCK=LOGIN_LOCK+1, LOCK_DATE =SYSDATE+1/24/60*5, TRY_CNT= 0 WHERE USERNAME=ID;
			DBMS_OUTPUT.PUT_LINE('5분후 부터 로그인이 가능합니다.');
		END IF;
	ELSE
		DBMS_OUTPUT.PUT_LINE('로그인이 불가능합니다.');
		INSERT INTO LOGIN_LOG VALUES( SEQ_LOG.NEXTVAL,RID, SYSDATE,'FAIL (LOCKED)' );
	END IF;
EXCEPTION
WHEN NO_DATA_FOUND	THEN
	DBMS_OUTPUT.PUT_LINE('일치하는 아이디가 없습니다.');
END;

SELECT * FROM LOGIN WHERE USERNAME='ID';
SELECT PASSWORD  FROM LOGIN WHERE USERNAME='ID1';

BEGIN
	PROC_LOGIN('ID','PW');
END;

BEGIN
	PROC_LOGIN('ID1','PW2');
END;

SELECT * FROM LOGIN;
SELECT * FROM LOGIN_LOG;

BEGIN
	PROC_LOGIN('ID2','PW1');
END;

UPDATE LOGIN SET LOCK_DATE =SYSDATE WHERE USERNAME='ID2';
